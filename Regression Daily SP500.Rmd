---
title: "sp500 regression"
author: "Joel Esparza"
date: "2024-04-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)
library(caret)
#sp500 <- read.csv('daily_sp500_regression.csv')
#head(sp500)
#str(sp500)
```

```{r}
sp500 <- read.csv('standardized_daily_sp500_regression.csv')
head(sp500)
str(sp500)
```

```{r}
sp500 <- sp500 %>% rename(proper = `proper.`)

# Convert specified columns to factors with only two levels
sp500 <- sp500 %>%
  mutate(
    move_avg_10 = as.factor(ifelse(X10_day_ma > PRC, 1, 0)),
    move_avg_20 = as.factor(ifelse(X20_day_ma > PRC, 1, 0)),
    move_avg_30 = as.factor(ifelse(X30_day_ma > PRC, 1, 0)),
    comp_size = as.factor(comp_size),  
    proper = as.factor(ifelse(proper == "True", 1, 0))
  )
```


```{r}
library(corrplot)

# Select only the numeric variables from your dataset
numeric_data <- sp500 %>%
  select_if(is.numeric)

# Calculate the correlation matrix
correlation_matrix <- cor(na.omit(numeric_data))


# Display the correlation matrix in a grid format
corrplot(correlation_matrix, method = "square", type = "upper", order = "hclust")
```


# Lasso-Regression
```{r}
library(tidyverse)
library(caret)
library(glmnet)


sp500 <- na.omit(sp500)


# Convert specified columns to factors
sp500[c("comp_size", "proper", "dummy_negative", "dummy_positive", "dummy_total")] <- 
  lapply(sp500[c("comp_size", "proper", "dummy_negative", "dummy_positive", "dummy_total")], 
         function(x) as.factor(x))


# Drop columns you want to exclude
columns_to_drop <- c("date", "PERMNO", "COMNAM", "SICCD", "TICKER", "SHROUT", "PRC", "BIDLO", "ASKHI", "market_cap", "X10_day_ma", "X20_day_ma", "X30_day_ma", "RETX") 
sp500_ <- sp500[, !(names(sp500) %in% columns_to_drop)]

# Drop rows with missing values
sp500_clean <- na.omit(sp500_)

# Convert sp500 into a matrix and create dummy variables for character variables
x <- model.matrix(tomorrow_return ~ ., sp500_clean)[,-1]

# Outcome
y <- sp500_clean$tomorrow_return

# Set seed
set.seed(17)

# Create training and test indices using createDataPartition
train_index <- createDataPartition(y, p = 0.7, list = FALSE)


# Subset the data based on the indices
x_train <- x[train_index, ]
y_train <- y[train_index]
x_test <- x[-train_index, ]
y_test <- y[-train_index]

# Fit Lasso regression model
fit <- cv.glmnet(x_train, y_train, alpha = 1, type.measure = "mse", nfolds = 5)

# Sequence of lambda values
lambda_values <- fit$lambda

# Dimensions of Lasso regression coefficients
dim(coef(fit))

# Plot coefficients on log of lambda values
plot(fit, xvar = "lambda")

# Lambda that corresponds to the lowest cross-validated MSE
lambda_best <- fit$lambda.min

# Model with the Best Lambda
# Lasso regression coefficients
coef_lambda_best <- predict(fit, s = lambda_best, type = "coefficients")

# Non-zero coefficients
non_zero_coefs <- coef_lambda_best[coef_lambda_best != 0]

# Make predictions for records in the test set
pred_lambda_best <- predict(fit, s = lambda_best, newx = x_test)

# MSE in the test set
MSE <- mean((y_test - pred_lambda_best)^2)
MSE

```



```{r}

options(scipen = 999)

# Make predictions for the entire dataset
lasso_pred <- predict(fit, newx = x, s = lambda_best)

sp5002 <- na.omit(sp500)

# Add the predictions as a new column to the original dataset
sp5002$lasso_pred <- lasso_pred
```

```{r}
library(ggplot2)

# Create a data frame with actual and predicted values
plot_data <- data.frame(
  actual = sp5002$tomorrow_return,
  s1 = sp5002$lasso_pred
)

# Create the plot
plot <- ggplot(plot_data, aes(x = actual, y = s1)) +
  geom_point() +
  geom_abline(slope = 0.00001, intercept = 0, color = "red") +
  geom_abline(slope = 0, intercept = 0, color = "blue") + 
  labs(x = "Actual Value", y = "Predicted Value") + 
  theme_minimal() +  
  theme(
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.border = element_rect(color = "black", fill = NA),  
    axis.line = element_line(color = "black"), 
    legend.position = "none" 
  )

# Calculate points in each quadrant
upper_right <- sum(plot_data$s1 > 0 & plot_data$actual > 0)
upper_left <- sum(plot_data$s1 > 0 & plot_data$actual < 0)
lower_right <- sum(plot_data$s1 < 0 & plot_data$actual > 0)
lower_left <- sum(plot_data$s1 < 0 & plot_data$actual < 0)

# Create mini grid/table
quadrant_table <- data.frame(
  Quadrant = c("Upper Right", "Upper Left", "Lower Right", "Lower Left"),
  Count = c(upper_right, upper_left, lower_right, lower_left)
)

# Print the plot and the quadrant table
print(plot)
print(quadrant_table)

```



## Random Forest
```{r}
library(rpart)
library(rpart.plot)


# Drop columns you want to exclude
columns_to_drop <- c("date", "PERMNO", "COMNAM", "SICCD", "TICKER", "SHROUT", "PRC", "BIDLO", "ASKHI", "market_cap", "X10_day_ma", "X20_day_ma", "X30_day_ma", "RETX") 
sp500_ <- sp500[, !(names(sp500) %in% columns_to_drop)]

# Drop rows with missing values
sp500_clean <- na.omit(sp500_)

# Set the seed 
set.seed(86)
    
# Row numbers of the training set
n_rows <- nrow(sp500_clean)
n_train <- round(0.7 * n_rows)
train_index <- sample(1:n_rows, n_train)
    
# Training set
train_sp500 <- sp500_clean[train_index, ]
    
# Test set 
test_sp500 <- sp500_clean[-train_index, ]

# Calculate lower and upper bounds for trimming outliers
lower_bound <- quantile(train_sp500$tomorrow_return, 0.025)  # Adjust percentile as needed
upper_bound <- quantile(train_sp500$tomorrow_return, 0.975)  # Adjust percentile as needed

# Trim outliers from the training set
train_sp500 <- train_sp500[train_sp500$tomorrow_return >= lower_bound & train_sp500$tomorrow_return <= upper_bound, ]

```



```{r}
# Regression tree with cp = 0.01
rt <- rpart(tomorrow_return ~ ., data = train_sp500, method = "anova", cp = 0.0001, maxdepth = 30)

# Plot the tree
#prp(rt, type = 1, extra = 1, cex = 0.8)
```


```{r}
# Predict
rt_pred <- predict(rt, newdata = test_sp500, type = "vector")

# First six values 
head(rt_pred)
```


```{r}
mse_rt <- mean((test_sp500$tomorrow_return - rt_pred)^2)
mse_rt
```


```{r}

# Plot the predicted values vs. actual values
library(ggplot2)
ggplot(data = test_sp500, aes(x = tomorrow_return, y = rt_pred)) +
  geom_point(color = "blue") +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(x = "Actual Tomorrow Return", y = "Predicted Tomorrow Return",
       title = "Predicted vs. Actual Tomorrow Return") +
  geom_hline(yintercept = 0, color = "black") +
  geom_vline(xintercept = 0, color = "black")

```

```{r}
# Classify predicted values into positive and negative
predicted_class <- ifelse(rt_pred > 0, "Positive", "Negative")
actual_class <- ifelse(test_sp500$tomorrow_return > 0, "Positive", "Negative")

# Create the confusion matrix
conf_matrix <- table(Actual = actual_class, Predicted = predicted_class)

# Print the confusion matrix
print(conf_matrix)
```

```{r}
# Predict using the random forest model
sp5002$pred_forest <- predict(rt, newdata = sp5002, type = "vector")

# Check the structure of the dataframe to ensure the new column is added
str(sp5002)

```
## Logistic Regression
```{r}
library(caret)

# Convert tomorrow_return to binary outcome (positive or negative)
sp500_clean$binary_return <- ifelse(sp500_clean$tomorrow_return >= 0, "Positive", "Negative")


# Set the seed for reproducibility
set.seed(123)

# Split the dataset into training and test sets
train_index <- createDataPartition(sp500_clean$binary_return, p = 0.7, list = FALSE)
train_set <- sp500_clean[train_index, ]
test_set <- sp500_clean[-train_index, ]

# Set up cross-validation
control <- trainControl(method = "cv",  # 10-fold cross-validation
                        number = 10,
                        classProbs = TRUE,  # Include class probabilities
                        summaryFunction = twoClassSummary)  # Use two-class summary for binary outcome

# Train logistic regression model with cross-validation
logit_model <- train(binary_return ~ . - tomorrow_return, 
                     data = train_set, 
                     method = "glm", 
                     family = binomial,
                     trControl = control)

# Make predictions on the test set
predicted <- predict(logit_model, newdata = test_set, type = "raw")

```

```{r}
# View model summary
summary(logit_model)

# View coefficients
coef(logit_model)
```

```{r}
# Make predictions on the entire dataset
sp5002$log_pred <- predict(logit_model, newdata = sp5002, type = "raw")

# View the updated dataset with predictions
head(sp5002)

```
```{r}
# Categorize the predictions and actual values without adding a new column
category_counts <- table(ifelse(sp5002$log_pred == 'Positive' & sp5002$tomorrow_return > 0, "Both Positive",
                           ifelse(sp5002$log_pred == 'Negative' & sp5002$tomorrow_return < 0, "Both Negative",
                                  ifelse(sp5002$log_pred == 'Positive' & sp5002$tomorrow_return < 0, "One Positive and One Negative",
                                         ifelse(sp5002$log_pred == 'Negative' & sp5002$tomorrow_return > 0, "One Negative and One Positive", "Other")))))

# View the counts
category_counts

```



```{r}
# Save the dataset with predictions to a CSV file
write.csv(sp5002, "Daily sp500 Trading Strategy.csv", row.names = FALSE)
```

